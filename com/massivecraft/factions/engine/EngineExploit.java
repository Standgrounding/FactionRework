package com.massivecraft.factions.engine;

import com.massivecraft.factions.entity.MConf;
import com.massivecraft.massivecore.Engine;
import com.massivecraft.massivecore.collections.MassiveList;
import com.massivecraft.massivecore.ps.PS;
import com.massivecraft.massivecore.util.MUtil;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.UUID;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.entity.Player;
import org.bukkit.entity.TNTPrimed;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.block.BlockFromToEvent;
import org.bukkit.event.entity.EntityExplodeEvent;
import org.bukkit.event.player.PlayerMoveEvent;
import org.bukkit.event.player.PlayerTeleportEvent;
import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;



public class EngineExploit
  extends Engine
{
  public EngineExploit() {}
  
  private static EngineExploit i = new EngineExploit();
  public static EngineExploit get() { return i; }
  





  @EventHandler(priority=EventPriority.NORMAL, ignoreCancelled=true)
  public void obsidianGenerators(BlockFromToEvent event)
  {
    if (!gethandleExploitObsidianGenerators) { return;
    }
    
    Block block = event.getToBlock();
    int source = event.getBlock().getTypeId();
    int target = block.getTypeId();
    if (((target == 55) || (target == 132)) && ((source == 0) || (source == 10) || (source == 11)))
    {
      block.setType(Material.AIR);
    }
  }
  




  @EventHandler(priority=EventPriority.NORMAL, ignoreCancelled=true)
  public void enderPearlClipping(PlayerTeleportEvent event)
  {
    if (!gethandleExploitEnderPearlClipping) return;
    if (event.getCause() != PlayerTeleportEvent.TeleportCause.ENDER_PEARL) { return;
    }
    
    Location target = event.getTo();
    Location from = event.getFrom();
    

    Material mat = event.getTo().getBlock().getType();
    if (((mat != Material.THIN_GLASS) && (mat != Material.IRON_FENCE)) || (
      (clippingThrough(target, from, 0.65D)) || (((mat == Material.FENCE) || (mat == Material.NETHER_FENCE)) && 
      (clippingThrough(target, from, 0.45D)))))
    {

      event.setTo(from);
      return;
    }
    

    target.setX(target.getBlockX() + 0.5D);
    target.setZ(target.getBlockZ() + 0.5D);
    event.setTo(target);
  }
  

  public static boolean clippingThrough(Location target, Location from, double thickness)
  {
    return 
    
      ((from.getX() > target.getX()) && (from.getX() - target.getX() < thickness)) || 
      ((target.getX() > from.getX()) && (target.getX() - from.getX() < thickness)) || 
      ((from.getZ() > target.getZ()) && (from.getZ() - target.getZ() < thickness)) || (
      (target.getZ() > from.getZ()) && (target.getZ() - from.getZ() < thickness));
  }
  



  private static final int NETHER_TRAP_RADIUS_CHECK = 5;
  

  private static final int NETHER_TRAP_RESET_RADIUS_SQUARED = 9;
  

  @EventHandler(priority=EventPriority.MONITOR, ignoreCancelled=true)
  public void tntWaterlog(EntityExplodeEvent event)
  {
    if (!gethandleExploitTNTWaterlog) return;
    if (!(event.getEntity() instanceof TNTPrimed)) { return;
    }
    Block center = event.getLocation().getBlock();
    if (!center.isLiquid()) { return;
    }
    
    List<Block> targets = new ArrayList();
    targets.add(center.getRelative(0, 0, 1));
    targets.add(center.getRelative(0, 0, -1));
    targets.add(center.getRelative(0, 1, 0));
    targets.add(center.getRelative(0, -1, 0));
    targets.add(center.getRelative(1, 0, 0));
    targets.add(center.getRelative(-1, 0, 0));
    for (Block target : targets)
    {
      int id = target.getTypeId();
      
      if ((id != 0) && ((id < 7) || (id > 11)) && (id != 49) && (id != 90) && (id != 116) && (id != 119) && (id != 120) && (id != 130))
      {
        target.breakNaturally();
      }
    }
  }
  









  private HashMap<UUID, List<Block>> portalTraps = new HashMap();
  

  @EventHandler(priority=EventPriority.MONITOR, ignoreCancelled=true)
  public void portalTrapRemoveAnimation(PlayerTeleportEvent event)
  {
    if ((!gethandleNetherPortalTrap) || (event.getCause() != PlayerTeleportEvent.TeleportCause.NETHER_PORTAL)) { return;
    }
    Player player = event.getPlayer();
    Block from = event.getTo().getBlock();
    

    if (EnginePermBuild.canPlayerBuildAt(player, PS.valueOf(from), false)) { return;
    }
    
    portalReset(player);
    

    List<Block> portalTrap = getPortal(from);
    if (portalTrap.isEmpty()) { return;
    }
    
    portalTraps.put(player.getUniqueId(), portalTrap);
    portalUpdateAir(player, portalTrap);
  }
  

  @EventHandler(priority=EventPriority.MONITOR, ignoreCancelled=true)
  public void portalUpdate(PlayerMoveEvent event)
  {
    if ((!gethandleNetherPortalTrap) || (MUtil.isSameBlock(event))) { return;
    }
    Player player = event.getPlayer();
    UUID uuid = player.getUniqueId();
    

    List<Block> portalTrap = (List)portalTraps.get(uuid);
    if (portalTrap == null) { return;
    }
    Location locationTo = event.getTo();
    Location locationFrom = ((Block)portalTrap.get(0)).getLocation();
    
    World worldTo = locationTo.getWorld();
    World worldFrom = locationFrom.getWorld();
    

    if ((!worldTo.equals(worldFrom)) || (locationTo.distanceSquared(locationFrom) > 9.0D))
    {
      portalUpdateReset(player, portalTrap);
      return;
    }
    

    portalUpdateAir(player, portalTrap);
  }
  
  public void portalReset(Player player)
  {
    UUID uuid = player.getUniqueId();
    

    List<Block> portalTrap = (List)portalTraps.get(uuid);
    if (portalTrap == null) { return;
    }
    
    portalTraps.remove(uuid);
    

    if (!player.getWorld().equals(((Block)portalTrap.get(0)).getWorld())) return;
    portalUpdateReset(player, portalTrap);
  }
  
  public static void portalUpdateReset(Player player, List<Block> portal) { portalUpdate(player, portal, null, null); }
  public static void portalUpdateAir(Player player, List<Block> portal) { portalUpdate(player, portal, Material.AIR, Byte.valueOf((byte)0)); }
  

  private static void portalUpdate(Player player, List<Block> portal, Material material, Byte data)
  {
    boolean usingDefault = (material == null) && (data == null);
    for (Block block : portal)
    {
      Material updateMaterial = usingDefault ? block.getType() : material;
      byte updateData = usingDefault ? block.getData() : data.byteValue();
      player.sendBlockChange(block.getLocation(), updateMaterial, updateData);
    }
  }
  

  public static List<Block> getPortal(Block from)
  {
    List<Block> ret = new MassiveList();
    

    for (int x = -5; x <= 5; x++)
    {
      for (int y = -5; y <= 5; y++)
      {
        for (int z = -5; z <= 5; z++)
        {
          if (from.getRelative(x, y, z).getType() == Material.PORTAL) { ret.add(from.getRelative(x, y, z));
          }
        }
      }
    }
    
    return ret;
  }
}
